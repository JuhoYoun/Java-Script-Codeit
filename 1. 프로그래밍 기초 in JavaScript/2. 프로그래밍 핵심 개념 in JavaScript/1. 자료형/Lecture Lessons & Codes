숫자형
-사칙연산, 나머지연산(modulus) % , 거듭제곱 
-계산 순서는 수학이랑 같다


문자열
- 문자열은 "" 나 '' 이렇게 감싼다
- 만약 '가 문자열 내에 포함되어있으면 문자열을 "" 이렇게 감싸면 된다 (반대상황도 동일)
- 문자열 내에 " 나 ' 가 모두 포함되어야할 때는 \ (역슬래쉬)를 쓸 수 있다 -> \' 또는 \" 이렇게 \ 뒤의 "나 '는 문자열이라고 인식한다
- 백틱 ` (숫자 1 옆에 있는 키보드 버튼)도 사용할 수 있다 -> `"I'm fine"` ->  이러면 \ 안쓰고도 "랑 ' 둘 다 문자열로 쓸 수 있다 -> 백틱은 맥에서 한글일때는 ₩ 영어일 때는 ` 이렇게 된다

부울 대수
- 진리값 true, false 
- 연산자 And Or Not
- 명제: 참 또는 거짓이 확실한 문장

불린형 

숫자 비교
ex) 2 > 1, 2 < 1, 2 <= 1, 3 >=4, 1 === 1, 1 !== 1

문자열 비교
ex) "codeit" === "codeit"

불린 연산
- AND 는 앰퍼샌드 기호 두개 -> &&
- OR 은 세로 바 두개 -> ||
- NOT 은 ! 기호

----------------------------------------------------------------------------------------------------------------------------------------------

불린형 연습

지난 시간에 불린형에 대해서 알아봤는데요. 이번 시간에는 지난 시간에 배운 것들을 활용해서 다양한 방식으로 불린형을 좀 더 연습해 봅시다.

// 불린 (Boolean)
console.log(2 < 1 && 'Codeit' !== 'Codeit');

2 < 1는 false고, 'Codeit' !== 'Codeit'도 false이기 때문에 이 코드는 false && false가 되어서 실행했을 때 false가 출력됩니다. 
그런데 사실, AND연산을 할 때 왼쪽이 false일 경우 오른쪽은 볼 필요도 없이 결과가 false입니다. AND연산은 양쪽이 모두 true인 경우에만 true가 리턴되기 때문이죠!
그래서 불린 연산자가 하나만 있을 때는 연산자를 기준으로 왼쪽부터 순서대로 확인하면 됩니다.

그럼 이 코드는 어떨까요?

// 불린 (Boolean)
console.log(7 !== 7 || 4 < 3);

이번에는 OR 연산인데요. OR연산의 경우에는 AND연산과 반대로 왼쪽이 true라면, 오른쪽은 볼 필요도 없이 결과는 true가 됩니다.
그런데 마침 OR연산의 왼쪽, 그러니까 7 !== 7이 false이기 때문에 이제 오른편도 확인해야 하네요.
4 < 3은 false이기 때문에 결과적으로 위 연산은 false OR false가 돼서 코드를 실행해보면 false가 출력됩니다.

마지막으로 하나만 더 해볼까요?

// 불린 (Boolean)
let x = 3;
console.log(x > 4 || !(x > 2));

이번에는 변수까지 활용해서 첫 번째 x라는 변수에 3이라는 값을 저장했습니다.
이번에는 조금 복잡해 보이니깐 여기 아래 코드를 하나 더 복사해서 부분부분 같이 수정하면서 확인해 봅시다.

// 불린 (Boolean)
let x = 3;
console.log(x > 4 || !(x > 2));
console.log(x > 4 || !(x > 2));

이번에도 순서대로 왼쪽의 비교연산부터 정리해 봅시다.

x > 4는 3 > 4가 되죠?

// 불린 (Boolean)
let x = 3;
console.log(x > 4 || !(x > 2));
console.log(3 > 4 || !(x > 2));

3 > 4는 false이기 때문에 오른쪽도 살펴봐야합니다.

// 불린 (Boolean)
let x = 3;
console.log(x > 4 || !(x > 2));
console.log(false || !(x > 2));

다음은 NOT연산이 있는데요. 그런데 어떤 값을 NOT연산 해야되는지 아직은 모르니깐, 괄호 안의 비교 연산을 정리해 봅시다.

x > 2는 3 > 2가 되죠?

let x = 3;
console.log(x > 4 || !(x > 2));
console.log(false || !(3 > 2));

3 > 2는 true입니다.

let x = 3;
console.log(x > 4 || !(x > 2));
console.log(false || !true);

그럼 이제 NOT연산도 정리해 줍시다.

let x = 3;
console.log(x > 4 || !(x > 2));
console.log(false || false);

결과적으로 위 연산은 false || false가 돼서

코드를 실행하면 false가 두 번 출력되는걸 확인할 수 있습니다.

let x = 3;
console.log(x > 4 || !(x > 2));
console.log(false);
false
false

-----------------------------------------------------------------------------------------------------------------------------

typeof 연산자

typeof 라는 키워드 옆에 값을 입력하면 해당 자료형을 문자열로 되돌려준다
ex) 
console.log(typeof "true") -> string
console.log(typeof 1) -> number JS는 정수와 소수를 따로 구분하지 않고 다 number 형이다
console.log(typeof 1.1) -> number

typeof 연산자는 변수와 함수에서도 활용가능
ex)
console.log(typeof name) -> string (name에 문자열이 할당되있다는 가정)
console.log(typeof sayHello) -> function (sayHello 라는 function이 있다 하자)

마지막으로 이번에는 typeof 연산자에 연산식을 넣어보도록 하자
->
console.log(typeof "code" + "it") -> stringit -> typeof 가 앞의 "code" 만 받아 "string" 을 반환하고 이게 "it" 이랑 합쳐진다
console.log(typeof 1 + 2) -> NAN 이라고 뜬다 NAN 은 not a number 라는 뜻 역시 typeof 가 앞에 1만 맏어 이걸 "number" 로 반환하고 문자열을 숫자형이랑 더하려니 이런 에러가 나온다

typeof 연산자는 사칙연산보다 우선순위가 높다 위의 경우에는 괄호를 사용하자
----------------------------------------------------------------------------------------------------------------------------------------

하나의 연산식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 우선순위(precedence)에 따라 결정됩니다.

5 + 3 * 6라는 기본적인 사칙연산의 식이 있을 때 곱셈이 먼저, 그 후에 덧셈이 일어난다는 것을 알고 계시죠? 이런 개념이 바로 연산자 우선순위입니다. 여기서 곱셈은 덧셈보다 더 높은 우선순위를 가진다고 할 수 있는 것이죠.

그리고 우리가 의도적으로 우선순위를 조절 하고 싶을 때도 사칙연산처럼 괄호를 사용하면 됩니다. (5 + 3) * 6라는 식에서는 곱셈보다 덧셈을 먼저 하는 것 처럼 말이죠.

자바스크립트에는 기본적인 사칙연산 외에도 다양한 연산자가 있습니다. 
그리고 이 모든 연산자에는 우선순위가 매겨져 있는데요. 우선순위 숫자가 클수록 먼저 실행됩니다.  순위가 같으면 대부분은 왼쪽부터 시작해서 오른쪽으로 연산이 수행되는데요.
(간혹  = 이나 ** 같은 몇몇 연산은 반대로 하는 경우도 있습니다.)

아래는 각 연산자들에 대한 우선순위를 정리한 표 입니다. 
잘 쓰이지 않거나, 특별한 경우에만 쓰이는 것들은 생략해 두었고, 주로 사용하는 것들에 대해서만 간단하게 요약해 놓았습니다. 생략된 부분이 궁금하시다면 노트 가장 아래 링크를 참조해 주세요! :)
우선순위	연산자 유형	기호
21	그룹	(...)
...		
17	논리 NOT	! ...
17	typeof	typeof ...
16	거듭제곱	... ** ...
15	곱셈	... * ...
15	나눗셈	... / ...
15	나머지	... % ...
14	덧셈	... + ...
14	뺄셈	... - ...
...		
12	미만	... < ...
12	이하	... <= ...
12	초과	... > ...
12	이상	... >= ...
11	동등	... == ...
11	부등	... != ...
11	일치	... === ...
11	불일치	... !== ...
...		
6	논리 AND	... && ...
5	논리 OR	... II ...
...		
3	할당	... = ...

다음 예시를 봅시다.

typeof (6 * 2 === 11 || 13 - 7 < 7 && !true);

일단 우선순위가 꽤 높은 typeof 연산자가 나오긴 했지만, 가장 높은 우선순위인 괄호가 있으니 괄호 내부를 먼저 연산해야 합니다.
그런데 괄호 내부에서도 다양한 연산자가 있습니다. 그럼 다시 이 괄호 내부에서 가장 높은 우선순위는 NOT연산자를 먼저 연산해줍시다.
true의 NOT연산이니깐, false가 되겠죠?

typeof (6 * 2 === 11 || 13 - 7 < 7 && false);

그 다음으로 높은 우선순위는 사칙연산이 되겠네요. 위 식에서는 곱셈과 뺄셈이 있으니 각각의 연산을 실행하면 아래와 같은 코드가 되겠죠?

typeof (12 === 11 || 6 < 7 && false);

이제 남은 연산자들 중에서 우선 순위가 가장 높은 연산자는 비교 연산입니다. 일치와 미만 연산을 해주면 아래와 같은 결과가 됩니다.

typeof (false || true && false);

이제 남은건 논리 연산입니다. 자칫 AND와 OR연산이 같은 우선순위라고 착각해서 순위가 같으니 왼쪽부터 차례대로 연산을 하려는 실수를 할 수도 있는데요. 우선순위 표를 자세히 살펴보시면 AND연산이 OR연산보다 우선순위가 한 단계 높습니다.

typeof (false || false);

true && false의 연산 결과는 false이니까, 결과적으로 괄호내부의 마지막 연산은 false || false가 됩니다.

typeof false;

결국 이 연산의 마지막은 typeof false가 되고, 이 모든 연산의 결과값은 문자열 'boolean'이 됩니다.

이렇게 복잡한 연산식을 작성할 때는 각 연산자들의 우선순위를 고려해서 작성해야 본인이 의도한 결과값을 확실하게 얻어낼 수 있고, 혹은 다른사람이 작성한 복잡한 연산식을 마주하게 될 때도, 이렇게 우선순위를 생각해서 이해를 하셔야 작성자의 의도를 명확하게 파악할 수 있습니다.

혹시 더 자세한 연산자 우선순위가 궁금하시다면 아래 링크를 참고해 보세요! :)

연산자 우선순위 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
-------------------------------------------------------------------------------------------------------------------------------------------

!= 와

!==의 차이가 뭔지 궁금합니다.


추가로

== 랑

=== 차이가 무엇인지도 궁금합니다...!

간단히 말하면

'==' 와 '!=' 는 value(값) 만 비교하는 것이고

5 == '5'
결과값 true

4 != '4'
결﻿과값 false


'===' 와 '!==' 는 value(값)과 Datatype(데이터 타입)까지 비교하는 것이라고합니다.

5 === '5'
결과값 false﻿


후자가 좀 더 엄격한 비교연산자로서 후자를 사용하는것을 추천한다고 하네용.


참고링크 https://aboooks.tistory.com/9
-------------------------------------------------------------------------------------------------------------------------------------------

형 변환 (Type Conversion)
ex) 
String(6) -> '6'
Number("1") -> 1

일반적으로 숫자가 아닌 형태의 문자열들은 숫자형으로 형 변환 시 NAN 값이 된다 (근데 NaN 의 타입은 숫자형인듯.... )
불린의 경우 true 는 숫자형으로 변환시 1로 면환되고 false 는 숫자형으로 변환시 0으로 변환된다 

Boolean 의 경우도 더 보자 
Boolean('문자') -> true
Boolean(123) -> true

일반적으로 어떤 값을 Boolean 으로 변환시키는 대부분 true 가 된다 
false 가 되는 경우를 알아보자
Boolean("") -> false 빈문자열 
Boolean(0) -> false 숫자 0 
Boolean(NaN) -> false Nan 인 경우 

이렇게 boolean 값으로 변형했을 때 false 가 나오는것을 falsy 값이라고 한다

우리가 직접 함수를 써 형변환 하는것 이외에도 자바스크립트에서는 일반적으로 연산을 할 때 일정한 규칙에 따라 자동으로 형변환을 하는 특징이 있다
ex)
console.log('4' - true);  -> 3 출력

상황에 따라서 유연하게 연산하는 이런 JS 특징이 장점이 될 수 있지만 이런 자동 형변환 규칙을 이해해야한다

산술 연산자 (+ - * / % **)
일반적으로 연산자들은 연산되어지는 두 값을 숫자형으로 바꾼 후 연산을 한다 (true : 1  false : 0) 단 더하기는 조심해야한다 다른 연산자들은 숫자를 연산하는 기능 밖에 없기 때문에 모두 숫자형으로 바꿔 연산하지만
더하기 연산자는 문자열을 연결하는 기능도 있다

console.log(4 + '2'); -> 42  쉽게 예기해서 JS에서 + 는 숫자를 더하는거 보다 문자열을 연결한다는 기능이 더 강하다고 생각하자

console.log(4 % "two") -> NaN "two" 는 NaN이다 NaN 값은 어떤것과 연산해도 NaN 값이 나온다


관계 비교 연산자 ( < > <= >= )
관계연산은 특별한 경우가 아니면 산술연산처럼 두 값을 모두 숫자형으로 바꿔서 비교한다
2 < '3' -> true
2 > true -> true
'2' <= false -> false
'two' >= 1 -> 이 경우 문자열 'two' 가 NaN으로 형변환 되고 두 값을 비교하는 이 관계 비교 연산자에서는 true 나 false 중 하나의 결과값을 내야하기 때문에 비교불가 경우에도 false 가 반환된다




