JS 에는 다양한 숫자 표현 방법이 있다

ex) 
let num = 2e9 (지수 표기법)
console.log(num) -> 2000000000

ex)
let num = -2e-3
console.log(num)  ->  -0.002

그리고 JS는 16진수 8진수 그리고 2진수를 표현하는 방법도 있다

//16진법 (Hexadecimal)
let hex1 = 0xff; // 255
let hex2 = 0xFF; // 255

//8진법 (Octal)
let octal = 0o377; //255

//2진법 (binary numeral system)
let binary = 0b11111111; // 255

console.log(hex1);
console.log(hex2);
console.log(octal);
console.log(binary);

--------------------------------------------------------------------------------------------------------------------------------

숫자도 객체이다 숫자형이 가지고 있는 메소드는 다루기 어려운데 이번에 두개만 다뤄보자

toFixed 메소드
소수를 다룰 때 사용되며 소수점 아래에 자리수를 고정할 때 사용한다 (반올림 한다) 범위는 0 부터 100 까지이고 만약에 패러미터로 들어가는 숫자가 숫자값의 자리수를 초과하는 경우에는 0으로 대체된다

let num =0.3567

console.log(num.toFixed(3)) -> 0.357
console.log(num.toFixed(7)) -> 0.3567000

주의해야할 점은 toFixed 메소드가 반환하는 값이 string 이라는 것이다 그래서 toFixed 가 반환하는 값을 숫자로 활용하려면 number 함수를 이용해서 숫자형으로 바꿔줘야한다 단 이때 자리수 채우기로 들어간 0 
은 제거된다

한가지 팁이 있는데 JS에서는 어떤 값 앞에 +를 붙이면 number 함수와 똑같은 결과를 얻을 수 있다
ex) console.log(+num.toFixed(7)) -> 0.3567

toString 메소드
패리미터로 전달하는 숫자의 진법으로 숫자를 변형시켜준다 범위는 2부터 36 까지이다 반환하는 값은 역시 문자열이다 

let num =125

console.log(num.toString(2)) -> 1111101
console.log(num.toString(8)) -> 175
console.log(num.toString(16)) -> 7d

마지막으로 한가지 집고 넘어갈 것이 있는데 지금까지는 변수에 숫자형을 담은 후 변수에 점 표기봅을 써 메소드를 호출했는데 변수에 담지 않고 숫자형에 바로 쓸 수도 있다 단 
255.toString(16) 이런식으로는 못쓴다 이렇게 쓰면 이 . 은 소수점을 시작하는 . 으로 인식되기 때문이다 그래서 정수형의 숫자값에는 메소드를 사용할 때 .. 이렇게 점 두개를 써줘야한다
-> 255..toString(16)   
또 다른 방법으로는 양옆에 괄호를 씌어줘도 된다

let num =125

console.log(125..toFixed(2)) -> 125.00
console.log(125.1.toFixed(2)) -> 125.10
console.log((125).toFixed(2)) -> 125.00

----------------------------------------------------------------------------------------------------------------------------------------------------

Date객체처럼 자바스크립트의 내장 객체 중 다양한 연산들을 유용하게 사용하기 위해 Math라는 객체가 있습니다.

이번 노트에서는 Math객체의 다양한 메소드에 대해 살펴봅시다.
절댓값 (Absolute Number)

학창 시절 수학 시간에서 배운 '절댓값(absolute value)' 기억하시나요?

간단하게 설명하자면, 어떤 값의 '양수(positive number)' 버전이라고 할 수 있습니다. 음수 -5의 절댓값은 양수 5고, 그냥 양수 5의 절댓값은 그대로 양수 5인 거죠.

Math.abs(x)를 하면 x의 절댓값이 리턴됩니다.

console.log(Math.abs(-10));
console.log(Math.abs(10));

10
10

최댓값 (Maximum)

Math.max 함수에 파라미터로 여러 수를 넘겨주면, 그중 가장 큰 값이 리턴됩니다.

console.log(Math.max(2, -1, 4, 5, 0));

5

최솟값 (Minimum)

Math.min 함수에 파라미터로 여러 수를 넘겨주면, 그중 가장 작은 값이 리턴됩니다.

console.log(Math.min(2, -1, 4, 5, 0));

-1

거듭제곱 (Exponentiation)

'제곱'의 개념 기억하시나요? '2의 3승'(혹은 '2의 세제곱')을 하면, 2를 세 번 곱한다는 뜻입니다. '2 곱하기 2 곱하기 2'를 하면 8이죠? 마찬가지로 '5의 2승'을 하면, '5 곱하기 5'를 해서 25입니다.

자바스크립트에서 Math.pow(x, y)를 하면 x의 y승의 결괏값이 리턴됩니다.

console.log(Math.pow(2, 3));
console.log(Math.pow(5, 2));

8
25

제곱근 (Square Root)

'제곱근(square root)'은 '제곱'의 반대라고 생각할 수 있습니다. 5의 제곱이 25이기 때문에, 25의 제곱근은 5입니다. 7의 제곱이 49이기 때문에, 49의 제곱근은 7입니다.

Math.sqrt(x)를 하면 x의 제곱근이 리턴됩니다.

console.log(Math.sqrt(25));
console.log(Math.sqrt(49));

5
7

반올림 (Round)

Math.round(x)를 하면 x의 반올림된 값이 리턴됩니다. 소수점 부분이 0.5 이상이면 가장 가까운 정숫값으로 올라가고, 소수점 부분이 0.5 미만이면 가장 가까운 정숫값으로 내려갑니다.

console.log(Math.round(2.3));
console.log(Math.round(2.4));
console.log(Math.round(2.49));
console.log(Math.round(2.5));
console.log(Math.round(2.6));

2
2
2
3
3

버림과 올림 (Floor and Ceil)

Math.floor(x)을 하면 x의 버림 값이, Math.ceil(x)을 하면 x의 올림 값이 리턴됩니다. 이 경우, 소수 부분이 얼마 인지와는 상관이 없습니다.

console.log(Math.floor(2.4));
console.log(Math.floor(2.49));
console.log(Math.floor(2.8));
console.log('-');
console.log(Math.ceil(2.4));
console.log(Math.ceil(2.49));
console.log(Math.ceil(2.8));

2
2
2
-
3
3
3

난수 (Random)

Math.random을 하면 0 이상 1 미만의 값이 랜덤으로 리턴됩니다.

console.log(Math.random());
console.log(Math.random());
console.log(Math.random());
console.log(Math.random());

0.21458369059793236
0.6622040803059857
0.785172717569619
0.9056556038884926

그리고...

이뿐만 아니라 '삼각 함수 계산'이나 '로그'같은 더 깊은 수학 계산도 가능합니다. 더 깊게 알아보고 싶다면 이 링크 를 참고해보세요!
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math
----------------------------------------------------------------------------------------------------------------------------------------

let sum = 0.1 + 0.2;
console.log(sum);  ->  0.3이 아니라 0.30000000000000004 이 출력된다 

그런데 이건 JS만이 아니라 파이썬 루비 자바등 다른 언어에서도 똑같이 발생하는 오류이다 이런 단순한 계산 오류는 왜 생기는걸까?
가장 큰 원인은 사람과 컴퓨터의 숫자를 다루는 방식이 서로 다르기 때문이다 컴퓨터의 모든 코드는 0과 1로 이루어져있다 우리가 적은 코드는 이진수로 변환된 다음에
컴퓨터가 해석을 하는데 우리가 3분의 1이라는 분수를 소수로 표현하면 0.33333333 이렇게 무한 소수로 표현된다 비슷한 원리로 우리가 일반적으로 사용하는 10진수의 숫자 표현을 이진수로 바꿔서 계산을 하다보면
무한소수가 되는 경우가 발생한다 그런데 이 무한소수는 말그대로 무한히 이어지기 때문에 명학하게 표시할 수 있는 방법이 없다 그래서 JS가 숫자를 표현할 수 있는 범위 내에서 특정한 자리에서 숫자를
반올림 하게 되는데 여기서 발생하는 아주 미세한 값의 차이가 바로 오차로 발생한다 

그럼 이 오차를 해결하는 방법을 얘기해보면 toFixed 메소드를 활용해서 필요한 자릿수에 맞춰서 반올림 되게 만들어주는거다 
->
let sum = 0.1 + 0.2;
console.log(+sum.toFixed(1));

아니면 Math 객체의 round 메소드를 활용해서 우리가 필요한 소수점 자리수 만큼의 10의 거듭 제곱을 곱한 뒤 round 메소드를 써준 뒤 다시 곱한 값으로 나줘준다 

let sum = 0.1 + 0.2;
console.log(Math.round(sum * 10) / 10)

다른 방법들도 있는데 여기까지만 다루자
------------------------------------------------------------------------------------------------------------------------------------

문자열 심화

문자열도 객체이므로 객체처럼 다룰 수 있다 문자열은 배열과 닮은 부분이 많다

length 프로퍼티 
배열처럼 문자열의 길이를 알려준다
ex)
let str = "Hello"
console.log(str.length) -> 5

문자열도 인덱스를 이용해서 글자 하나하나에 접근할 수 있다
ex)
let str = "Hello"
console.log(str[1]) -> e

또 문자열은 특별히 charAt 이라는 메소드를 활용해서 접근할 수 있다
ex)
let str = "Hello"
console.log(str.charAt(1)) -> e

또 배열에서 활용할 수 있는 indexOf와 lastIndexOf 를 활용해서 요소를 찾을 수도 있다 
ex)
let str = "Hello"
console.log(str.indexOf('H'))  -> 0
console.log(str.lastIndexOf('l'))  -> 3

toUpperCase 와 toLowerCase 
모두 대문자로 바꿔주거나 소문자로 바꾼 문자열을 리턴한다
ex)
let str = "Hello"
console.log(str.toUpperCase())  -> HELLO
console.log(str.toLocaleLowerCase())  -> hello

trim
문자열의 양쪽 공백을 모두 없앤 문자열을 리턴한다
ex)
let str = "  Hello  "
console.log(str)  ->Hello
console.log(str.trim())  ->  Hello

slice
부분 문자열을  메소드이다 두개의 파라미터를 가지고 있으며 시작과 끝 인덱스이다 한가지 주의할 점은 끝 인덱스 바로 직전까지의 범위를 가져온다는 것이다
ex)
let str = "Hello"
console.log(str.slice(1,3))  ->  el
console.log(str.slice(2))  ->  llo
console.log(str.slice())  -> Hello

---------------------------------------------------------------------------------------------------------------------------------------------------

문자열도 생각해보면 '문자' + '열'이기 때문에 배열과 비슷한 부분들이 많습니다.
비슷한 점

실제로 지난 시간에 배열과 문자열 모두 length프로퍼티를 가지고 있고, 대괄호 표기법으로 각 요소에 접근할 수 있다거나..
꽤 많은 메소드들이 배열과 문자열 모두 동일하게 사용되는 것도 확인할 수 있었는데요. 심지어 지난 시간에 다루진 못했지만 배열을 다룰 때 유용한 for..of문을 문자열에 활용할 수도 있습니다.

let myString = 'Codeit';

for (let str of myString) {
  console.log(str);
}

C
o
d
e
i
t

다른 점

하지만 비슷하다고 해서 완전히 같다고는 할 수 없습니다.

let myString = 'Codeit';
let myArray = ['C', 'o', 'd', 'e', 'i', 't'];

console.log(typeof myString);
console.log(typeof myArray);

일단 typeof 연산자를 사용해서 두 값의 자료형을 비교해보면,

string
object

string과 object, 확실히 서로 다른 자료형인 걸 확인할 수 있고,

let myString = 'Codeit';
let myArray = ['C', 'o', 'd', 'e', 'i', 't'];

console.log(myString === myArray);
console.log(myString == myArray);

두 값을 서로 비교해 보아도

false
false

일치 비교뿐만 아니라, 느슨하게 비교하는 동등비교에서도 false가 출력되는걸 확인할 수 있습니다.
mutable vs. immutable

가장 중요한 차이는 배열은 'mutable(바뀔 수 있는)' 자료형인 반면 문자열은 'immutable(바뀔 수 없는)' 자료형이라는 것입니다.

배열은 요소에 접근해서 할당연산자를 통해 요소를 수정할 수 있었죠?

문자열은 한 번 할당된 값을 수정할 수 없습니다. 다르게 표현해서, 변수에 할당된 문자열을 바꾸고 싶다면, 일부를 바꾸는 게 아니라 새로운 문자열을 지정해주어야 한다는 것이죠.

// 배열은 mutable
let myArray = ['C', 'o', 'd', 'e', 'i', 't'];
myArray[0] = 'B';
console.log(myArray);

// 문자열은 immutable
let myString = 'Codeit';
myString[0] = 'B';
console.log(myString);

(6) ["B", "o", "d", "e", "i", "t"]
Codeit

다시 한번 되돌아보면, 문자열이 가진 메소드들은 모두 retrun 값들을 활용하고, 본래의 문자열 값을 수정하지 않습니다. 
같은 의미에서 문자열에 splice 같은 메소드들은 사용할 수 없겠죠?

문자열과 배열은 서로 비슷하지만 엄연히 다른 차이가 있다는 점 꼭 기억해 주세요!

---------------------------------------------------------------------------------------------------------------------------------------------

기본형과 참조형

자료형 (Data Type)
지금까지 배운 자료형들을 모두 나열해보면 숫자형 문자열 불린형 널 언디파인드 그리고 객체를 살펴봤는데 그 중에서 객체를 제외한 나머지를 기본형, 기본타입 영어로는 Primitive Type 이라고 한다
우리가 어떤 값을 다룰 때 특별한 경우를 제외하면 모두 변수에 할당해서 사용하는데 JS에서 변수에 기본형을 할당하면 해당 이름을 가진 상자에 그 값을 넣어준다고 생각할 수 있다 

그럼 객체는 어떻게 다를까?

